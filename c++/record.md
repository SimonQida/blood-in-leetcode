### leetcode题解记录

- 869 有两组数做比较的时候，抓住变化少的数反向对比，对比的手法适当裁剪(仅需达到题目要求即可)

- 437 使用前缀和的技巧，这个是零日解法中想到的，但是只想到了每层是用vector存储上层节点数据，导致时间空间占用都比较多。看了有使用hash保存上层节点前缀和的很厉害，key是前缀和数值x，value是有多少个x。

- 347 是可以使用最小堆求topk问题(当然最小堆要做一个后面来标记完成>?<),看到了一个更取巧的解法，最后需要topk的整数是被自然限制的，可以使用常量长度的数组保存，一次遍历处理

- 1302 树广度遍历，也叫层序遍历，简单题，不做

- 260 树dfs剪枝比动态规划高级，两个解法都有

- 136 异或找出单独数字

- 260 136的变式，要找出两个单个数字，通过异或结果的位将数组分成两个数组(两个数组里面各有一个单个数字)，然后在两个数组分别求出这两个数字

- 1371 undone

- 1337

- 85 hard 使用堆栈记录数据，计算权值大的区域的值

- 413, 1513 本质是一样的，计算最小子数组问题，一次遍历计算出即可

- 1395 贪心，从后往前算，每个节点作为首节点的结果数(加起来)，并计算自己作为第二节点时能给出多少可能。

- 438 特殊点： 注意size()返回的是uint ，直接使用时没问题，但是两个size()相减的时候，可能会减溢出..要记得转成int类型的再用！

- 679 hard 算24点 
	- 这里先使用暴力解法也就是dfs，暴力出所有的可能

- 575 使用set计算独有数字的数量，短路返回

- 695 bfs

- 500 easy to pass

- 1233 still need to think

- 343 求导

- 641 binary list

- 1051 排序之后，比较有几个位置的数值不一样

- 947 使用并查集, 这里可以巧妙的将坐标x y，映射到一个维度上，然后对于这两个因子做merge，并查集使用hash表可以减空间占用

- 997 使用两个数组记录每一个节点的入度和出度即可

- 802 使用反向图 + 拓扑排序找到无环的后向节点们

- 1631 计算变式的单源最短路径

- 0401 使用并查集记录点之间的父亲关系（起始点的父亲始终是自己），直到节点是终止节点并且该节点的父节点是起始点返回true， 遍历结束都没有那就返回false

- 797 dfs 使用回溯明显提升表现力

- 496 503 739 都是单调栈， 503使用取余来模拟翻倍数组。739在单调栈中保存index从而方便计算index差值，同时保证元素可溯源

- offer14 剪绳子动态规划解法 f(n) = max(x * f(n-x))

- 474 dp, 01背包

- 416 dp, 01背包

- 518 dp, 完全背包

- 10 正则表达式，递归dp + 缓存比较好写， 循环处理起来比较复杂

- 123 股票问题 先用遍历把思路踩一遍，然后使用状态机记录每种状态的结果，最后推导出所求结果??没搞定

- 76 滑动窗口双指针

- 576 

- 567 滑动窗口双指针， 这道题五次提交4次打脸，思路还是一次成型好呀。。

- 438 和567一样的，只是需要全扫完并记录所有结果的begin序号

- 1438 滑动窗口 + 单调队列

- 1208 滑动窗口双指针，直接解决

- 239 单调队列

- 0105 解答中给出的解法太魔幻了，直接一次遍历求解即可

- 565 直接往前踩，把踩过的赋特殊值

- 1161 层序遍历, ac的很艰辛，有问题了

- 119 层层累加

- 120 层层累加， 自底向上贪心算法

- 1574 使用堆栈保存靠后的递增数列，从头部开始遍历，同时去掉堆栈中小于当前游标的数字。注意退出的几种边界。

- 1753 想明白就很好做

- 693 位运算

- 0406 二叉树中序遍历

- 1754 没做，每次都比较两个字符串的头部的字母大小就能得到最终结果

- 649 使用计数器

- offer38 要注意理解题意，本来就是一道遍历题，搞得吃相很难看😇

- 235 二叉搜索树的最近公共祖先

- 236 普通二叉树的最近公共祖先， 递归思路解决

- 1227 比较有意思的题，是找规律做出来的，但是根据找出来规律之后又根据了结果推理出过程，很有意思的一道题，每多一个人都可以根据之前计算的结果推出当前结果。

- 106 中序后序数组得出 完整的二叉树。 根据后序数组的最后一位作为root，不断分割中序数组得出结果